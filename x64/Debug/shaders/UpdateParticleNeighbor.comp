// Pass 2: Compute shader - spatial hash insert z conflict resolution
layout(local_size_x = 256) in;

layout(std430, binding = 3) buffer TargetCells {
    uint targetCell[];  // Wynik z Pass 1: docelowa komórka każdej cząstki
};

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= particles.length()) return;

    ivec3 gridSize = ivec3((boundsMax - boundsMin) / cellSize);
    vec3 pos = particles[i].position;
    ivec3 cell = ivec3(floor((pos - boundsMin) / cellSize));
    uint key = uint(cell.x + cell.y * gridSize.x + cell.z * gridSize.x * gridSize.y);

    if (key >= totalCells) return;

    // Jeden atomik na cząstkę zamiast 30+
    uint old = atomicCompSwap(occupancy[key], OCCUPANCY_EMPTY, i);

    // Jeśli zajęte - przesuń do najbliższej wolnej (deterministycznie)
    if (old != OCCUPANCY_EMPTY && old != i) {
        const ivec2 offsets[8] = ivec2[8](
        ivec2(1,0), ivec2(0,1), ivec2(-1,0), ivec2(0,-1),
        ivec2(1,1), ivec2(-1,1), ivec2(-1,-1), ivec2(1,-1)
        );

        for (int r = 1; r <= 2; r++) {
            for (int j = 0; j < 8; j++) {
                ivec3 neighbor = cell + ivec3(offsets[j] * r, 0);
                if (neighbor.x < 0 || neighbor.x >= gridSize.x ||
                neighbor.z < 0 || neighbor.z >= gridSize.z) continue;

                uint nKey = uint(neighbor.x + neighbor.y * gridSize.x +
                neighbor.z * gridSize.x * gridSize.y);

                if (atomicCompSwap(occupancy[nKey], OCCUPANCY_EMPTY, i) == OCCUPANCY_EMPTY) {
                    particles[i].position = boundsMin + (vec3(neighbor) + 0.5) * cellSize;
                    particles[i].velocity *= 0.7;
                    return;
                }
            }
        }

        // Jeśli wszystko zajęte - zatrzymaj się
        particles[i].velocity = vec3(0.0);
    }
}