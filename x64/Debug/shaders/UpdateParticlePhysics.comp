#version 430 core

layout(std430, binding = 0) buffer Particles {
    GPUParticle particles[];
};

layout(std430, binding = 1) buffer GridOcc {
    coherent uint occupancy[];
};

layout(std140, binding = 2) uniform SimParams {
    float deltaTime;
    float gravity;
    float ambientPressure;
    float dampingFactor;
    float simulationHeight;
    float cellSize;
    float maxVelocity;
    uint  totalCells;
    vec3 boundsMin;
    float _pad0;
    vec3 boundsMax;
    float _pad1;
};

const uint EMPTY = 0xFFFFFFFFu;
const float VY_THRESHOLD = 0.05;

uint hash(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352du;
    x ^= x >> 15;
    return x;
}

uint gridKey(ivec3 p, ivec3 gs) {
    return uint(p.x + p.y * gs.x + p.z * gs.x * gs.y);
}

ivec3 worldToGrid(vec3 pos) {
    return ivec3(floor((pos - boundsMin) / cellSize));
}

bool tryOccupy(uint key, uint me) {
    if (key >= totalCells) return false;
    return atomicCompSwap(occupancy[key], EMPTY, me) == EMPTY;
}

// Pseudo-random offset based on particle ID - deterministyczny chaos
ivec2 randomOffset(uint seed, int iteration) {
    uint h = hash(seed + uint(iteration) * 73856093u);
    int x = int(h & 3u) - 1;
    int z = int((h >> 2) & 3u) - 1;
    return ivec2(x, z);
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= particles.length()) return;

    ivec3 gs = ivec3((boundsMax - boundsMin) / cellSize);
    GPUParticle p = particles[i];

    // Fizyka
    float buoyancy = (ambientPressure - p.pressure) * 0.001;
    p.velocity.y += (gravity + buoyancy) * deltaTime;

    float speed = length(p.velocity);
    if (speed > maxVelocity)
    p.velocity *= maxVelocity / speed;

    vec3 newPos = p.position + p.velocity * deltaTime;
    ivec3 oldCell = worldToGrid(p.position);
    uint oldKey = gridKey(oldCell, gs);

    // Bounds check
    bvec3 oob = lessThan(newPos, boundsMin) || greaterThan(newPos, boundsMax);
    if (any(oob)) {
        if (oob.x) { p.velocity.x *= -0.5; newPos.x = clamp(newPos.x, boundsMin.x, boundsMax.x); }
        if (oob.y) { p.velocity.y = 0.0; newPos.y = clamp(newPos.y, boundsMin.y, boundsMax.y); }
        if (oob.z) { p.velocity.z *= -0.5; newPos.z = clamp(newPos.z, boundsMin.z, boundsMax.z); }
    }

    ivec3 newCell = worldToGrid(newPos);
    uint newKey = gridKey(newCell, gs);

    bool moved = false;

    // Same cell - trivial
    if (newKey == oldKey) {
        p.position = newPos;
        moved = true;
    }
    // Try target cell
    else if (tryOccupy(newKey, i)) {
        atomicExchange(occupancy[oldKey], EMPTY);
        p.position = newPos;
        moved = true;
    }
    // Collision - search only if vertical movement
    else if (abs(p.velocity.y) > VY_THRESHOLD) {
        // Max 8 attempts - pseudo-random to avoid clustering
        for (int attempt = 0; attempt < 8; ++attempt) {
            ivec2 offset = randomOffset(i, attempt);
            ivec3 candidate = ivec3(oldCell.x + offset.x, oldCell.y, oldCell.z + offset.y);

            if (candidate.x < 0 || candidate.x >= gs.x ||
            candidate.z < 0 || candidate.z >= gs.z) continue;

            uint candKey = gridKey(candidate, gs);
            if (tryOccupy(candKey, i)) {
                atomicExchange(occupancy[oldKey], EMPTY);
                p.position = boundsMin + (vec3(candidate) + 0.5) * cellSize;
                p.velocity.xz *= 0.7;
                if (p.velocity.y < -0.05) p.velocity.y = 0.0;
                moved = true;
                break;
            }
        }
    }

    if (!moved) {
        p.velocity = vec3(0.0);
        p.position = boundsMin + (vec3(oldCell) + 0.5) * cellSize;
    }

    p.velocity *= dampingFactor;
    p.pressure = ambientPressure * (1.0 - (p.position.y / simulationHeight + 0.5) * 0.1);
    particles[i] = p;
}